#!/usr/bin/perl
#
# Build something.
#
# This file is part of macrobuild.
# (C) 2012-2017 Indie Computing Corp.
#
# macrobuild is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# macrobuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with macrobuild.  If not, see <http://www.gnu.org/licenses/>.
#

use strict;
use warnings;

use Getopt::Long;
use Macrobuild::CompositeTasks::Sequential;
use Macrobuild::Constants;
use Macrobuild::Task;
use Macrobuild::TaskRun;
use UBOS::Logging;
use UBOS::Utils;

my $verbose           = 0;
my $logConfigFile     = undef;
my $debug             = undef;
my $inputFile         = undef;
my $outputFile        = undef;
my $listShortcuts     = 0;
my $printVars         = 0;
my $printResolvedVars = 0;
my $dryRun            = 0;
my $help              = 0;

my $parseOk = GetOptions(
    'verbose+'            => \$verbose,
    'logConfig=s'         => \$logConfigFile,
    'debug'               => \$debug,
    'in=s'                => \$inputFile,
    'out=s'               => \$outputFile,
    'list-shortcuts'      => \$listShortcuts,
    'print-vars'          => \$printVars,
    'print-resolved-vars' => \$printResolvedVars,
    'dry-run|n'           => \$dryRun,
    'help'                => \$help );

if( $help ) {
    synopsisHelpQuit( 1 );
}
if(    !$parseOk
    || ( $printVars && $printResolvedVars )
    || ( $listShortcuts && ( $printVars || $printResolvedVars )))
{
    synopsisHelpQuit();
}

UBOS::Logging::initialize( 'macrobuild', undef, $verbose, $logConfigFile, $debug );

my $inputJson = {};
if( $inputFile ) {
    unless( -r $inputFile ) {
        fatal( 'Cannot find or ready input file:', $inputFile );
    }
    $inputJson = UBOS::Utils::readJsonFromFile( $inputFile );
}

# Init global settings

my ( $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst ) = gmtime( time() );
my $constants = Macrobuild::Constants->new(
        'default',
        {
            'tstamp' => ( sprintf "%.4d%.2d%.2d-%.2d%.2d%.2d", ($year+1900), ( $mon+1 ), $mday, $hour, $min, $sec )
        } );
for my $defaultsFile ( './settings.pl', './local.pl' ) { # leading ./ required
    if( -e $defaultsFile ) {
        $constants = Macrobuild::Constants->readAndCreate( $defaultsFile, $constants );
    }
}
my $allShortcuts = $constants->getAll( 'shortcuts', undef );

# Now figure out the task(s) to run -- we either find the single task, or assemble a Sequential

my( $rootTask, $rootTaskConstants ) = _parseArgvToTask( \@ARGV, $constants );

if( $printVars || $printResolvedVars ) {
    my $vars = $constants->getAllWithAllValues( $printResolvedVars );
    my $max = length( '(overridden)' ) + 2;
    foreach my $key ( keys %$vars ) {
        if( length( $key ) > $max ) {
            $max = length( $key );
        }
    }
    foreach my $key ( sort keys %$vars ) {
        my $values = $vars->{$key};
        printf "%-" . $max . "s: %s\n", $key, _var2string( $values->[0] );
        for( my $i=1 ; $i<@$values ; ++$i ) {
            printf "%" . $max . "s  %s\n", '(overridden)', _var2string( $values->[$i] );
        }
    }
    exit 0;
}

if( $listShortcuts ) {
    if( @$allShortcuts ) {
        my $mergedShortcuts = {};
        for my $all ( @$allShortcuts ) {
            for my $key ( keys %$all ) {
                unless( exists( $mergedShortcuts->{$key} )) {
                    $mergedShortcuts->{$key} = $all->{$key};
                }
            }
        }

        use IO::Handle;
        STDOUT->autoflush; # make sure it appears before subroutine bails out in case of error

        if( $verbose ) {
            my $max = 8;
            foreach my $short ( keys %$mergedShortcuts ) {
                if( length( $short ) > $max ) {
                    $max = length( $short );
                }
            }
            foreach my $short ( sort keys %$mergedShortcuts ) {
                my $long = $mergedShortcuts->{$short};
                if( ref( $long ) eq 'ARRAY' ) {
                    $long = join( ' ', @$long );
                }
                printf "%-" . $max . "s => %s\n", $short, $long;
            }
        } else {
            foreach my $short ( sort keys %$mergedShortcuts ) {
                print "$short\n";
            }
        }
    } else {
        print "No short task names defined.\n";
    }
    exit 0;
}

if( $dryRun ) {
    print join( '', map { $_->name() . "\n" } $rootTask->tasks() );

    exit 0;
}

my $taskRun = Macrobuild::TaskRun->new( $inputJson, $rootTaskConstants, $rootTask );
my $exit    = $rootTask->run( $taskRun );

if( $exit < 0 ) {
    error( 'Aborting with error' );
    exit( $exit );
} elsif( $exit > 0 ) {
    info( 'Nothing to do.' );
    exit( 0 );
}

my $output = $taskRun->getOutput();
if( $outputFile ) {
    UBOS::Utils::writeJsonToFile( $outputFile, $output );
} elsif( keys %$output ) {
    UBOS::Utils::writeJsonToStdout( $taskRun->getOutput() );
}
exit( 0 );

#####
sub _parseArgvToTask {
    my $args            = shift;
    my $parentConstants = shift;

    my $retTask         = undef;
    my $retConstants    = $parentConstants;
    my $currentTaskName = undef;
    my $currentVars     = {};

    for my $arg ( @$args ) {
        if( $arg =~ m!^([^=]+)=(.*)$! ) {
            my( $key, $value ) = ( $1, $2 );
            if( exists( $currentVars->{$key} )) {
                fatal( 'Argument provided more than once:', $key );
            }
            $currentVars->{$key} = $value;

        } else {
            unless( $currentTaskName ) { # we don't have a task yet (just about to get one), so this is env vars
                $retConstants = Macrobuild::Constants->new(
                        'env vars for ' . join( ' ', @$args ),
                        $currentVars,
                        $parentConstants );

                $currentVars = {};
            }
            if( $currentTaskName ) { # we just finished parsing a task
                my $newTask = _createTask( $currentTaskName, $currentVars );
                if( $retTask ) {
                    unless( ref $retTask eq 'Macrobuild::CompositeTasks::Sequential' ) {
                        $retTask = Macrobuild::CompositeTasks::Sequential->new( 'tasks' => [ $retTask ] );
                    }
                    $retTask->appendTask( $newTask );
                } else {
                    $retTask = $newTask;
                }
                
                $currentTaskName = undef;
                $currentVars     = {};
            }
            $currentTaskName = $arg;
        }
    }
    if( $currentTaskName ) {
        my $newTask = _createTask( $currentTaskName, $currentVars );
        if( $retTask ) {
            unless( ref $retTask eq 'Macrobuild::CompositeTasks::Sequential' ) {
                $retTask = Macrobuild::CompositeTasks::Sequential->new( 'tasks' => [ $retTask ] );
            }
            $retTask->appendTask( $newTask );
        } else {
            $retTask = $newTask;
        }
    } else {
        fatal( 'No task name(s) given' );
    }

    return ( $retTask, $retConstants );
}

#####
sub _createTask {
    my $taskName        = shift;
    my $vars            = shift;
    my $parentConstants = shift;

    my $ret = undef;
    # shortcuts can be defined in all files, and don't override each other
    if( $allShortcuts ) {
        for my $shortcuts ( @$allShortcuts ) {
            if( exists( $shortcuts->{$taskName} )) {
                my $discard;
                ( $ret, $discard ) = _parseArgvToTask( $shortcuts->{$taskName}, $parentConstants );
                last;
            }
        }
    }
    unless( $ret ) {
        if( $taskName =~ m!::! ) {
            # Perl package name has been given as a task name
            eval "require $taskName" || fatal( 'Cannot load package', "$taskName\n", $@ );

        } else {
            my $fileName = $taskName;
            if( $fileName =~ m!^(.*)\.pm$! ) {
                $taskName = $1;
            } else {
                $fileName = "$fileName.pm";
            }
            eval "require '$fileName';" || fatal( 'Cannot read file', "$fileName\n", $@ );
            $taskName =~ s!/!::!g;
        }
        $ret = $taskName->new( %$vars );
    }
    return $ret;
}

#####
sub _var2string {
    my $s = shift;

    if( !defined( $s )) {
        return '<undef>';
    }
    if( ref( $s ) eq 'ARRAY' ) {
        return '[ ' . join( ', ', map { _var2string( $_ ) } @$s ) . ' ]';
    }
    if( ref( $s ) eq 'HASH' ) {
        return '[ ' . join( ', ', map { "$_ => " . _var2string( $s->{$_} ) } sort keys %$s ) . ' ]';
    }
    return $s;
}

#####
sub synopsisHelpQuit {
    my $long = shift || 0;

    print "Synopsis $long\n";

    exit( 0 );
}



1;
